---
title: "CellChat_BC_Project"
author: "Beth Cragg"
date: "2025-06-23"
output:
  word_document: default
  html_document: default
  pdf_document: default
#CellChat Analysis - BC Research Project v2.0
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(CellChat)
library(Seurat)
library(cowplot)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(CellChat)
#source("Utils.R")
library(tidyverse)
library(NMF)
library(circlize)
library(ComplexHeatmap)
```

# Run CellChat preprocessing for each timepoint separately and then merge conditions at the end
```{r, echo=false}

#Read in final Seurat objects (by timepoint)
control_seurat <- readRDS(file = "2025_MSc_control.rds")
h24_seurat <- readRDS(file = "2025_MSc_24.rds")
h48_seurat <- readRDS(file = "2025_MSc_48.rds")

#  - - - - - CONTROL - - - - - - 
# Extract normalised data & metadata
data.input.control <- GetAssayData(control_seurat, assay = "RNA", layer= "data")  # log-normalized counts
meta.control <- data.frame(labels = control_seurat$cell_type_broad, row.names = colnames(control_seurat))
rownames(meta.control) <- colnames(data.input.control)

cellchat.control <- createCellChat(object = data.input.control, meta = meta.control, group.by = "labels")
cellchat.control <- addMeta(cellchat.control, meta = meta.control)
cellchat.control <- setIdent(cellchat.control, ident.use = "labels")

# Set DB to mouse
cellchat.control@DB <- CellChatDB.mouse

# Preprocessing pipeline
cellchat.control <- subsetData(cellchat.control)
cellchat.control <- identifyOverExpressedGenes(cellchat.control, do.fast = FALSE)
cellchat.control <- identifyOverExpressedInteractions(cellchat.control)
cellchat.control <- computeCommunProb(cellchat.control)
cellchat.control <- filterCommunication(cellchat.control, min.cells=10)
cellchat.control <- computeCommunProbPathway(cellchat.control)
cellchat.control <- aggregateNet(cellchat.control)
cellchat.control <- netAnalysis_computeCentrality(cellchat.control)



#  - - - - - 24 HRS - - - - - - 
# Extract normalised data & metadata
data.input.h24 <- GetAssayData(h24_seurat, assay = "RNA", layer= "data")  # log-normalized counts
meta.h24 <- data.frame(labels = h24_seurat$cell_type_broad)
rownames(meta.h24) <- colnames(data.input.h24)

cellchat.h24 <- createCellChat(object = data.input.h24, meta = meta.h24, group.by = "labels")
cellchat.h24 <- addMeta(cellchat.h24, meta = meta.h24)
cellchat.h24 <- setIdent(cellchat.h24, ident.use = "labels")

# Set DB to mouse
cellchat.h24@DB <- CellChatDB.mouse

# Preprocessing pipeline
cellchat.h24 <- subsetData(cellchat.h24)
cellchat.h24 <- identifyOverExpressedGenes(cellchat.h24, do.fast = FALSE)
cellchat.h24 <- identifyOverExpressedInteractions(cellchat.h24)
cellchat.h24 <- computeCommunProb(cellchat.h24)
cellchat.h24 <- filterCommunication(cellchat.h24, min.cells=10)
cellchat.h24 <- computeCommunProbPathway(cellchat.h24)
cellchat.h24 <- aggregateNet(cellchat.h24)
cellchat.h24 <- netAnalysis_computeCentrality(cellchat.h24)



#  - - - - - 48 HRS - - - - - - 
# Extract normalised data & metadata
data.input.h48 <- GetAssayData(h48_seurat, assay = "RNA", layer= "data")  # log-normalized counts
meta.h48 <- data.frame(labels = h48_seurat$cell_type_broad)
rownames(meta.h48) <- colnames(data.input.h48)

cellchat.h48 <- createCellChat(object = data.input.h48, meta = meta.h48, group.by = "labels")
cellchat.h48 <- addMeta(cellchat.h48, meta = meta.h48)
cellchat.h48 <- setIdent(cellchat.h48, ident.use = "labels")

# Set DB to mouse
cellchat.h48@DB <- CellChatDB.mouse

# Preprocessing pipeline
cellchat.h48 <- subsetData(cellchat.h48)
cellchat.h48 <- identifyOverExpressedGenes(cellchat.h48, do.fast = FALSE)
cellchat.h48 <- identifyOverExpressedInteractions(cellchat.h48)
cellchat.h48 <- computeCommunProb(cellchat.h48)
cellchat.h48 <- filterCommunication(cellchat.h48, min.cells=10)
cellchat.h48 <- computeCommunProbPathway(cellchat.h48)
cellchat.h48 <- aggregateNet(cellchat.h48)
cellchat.h48 <- netAnalysis_computeCentrality(cellchat.h48)


#  - - - - - MERGE - - - - - - 
#Create a list of the objects from each condition
object.list <- list(
  Cycling = cellchat.control,
  H24 = cellchat.h24,
  H48 = cellchat.h48
)

#use the inbuilt merge function to create a single CellChat object
cellchat <- mergeCellChat(object.list, add.names = names(object.list))

```


## Compare the total number of interactions and interaction strength
To answer on question on whether the cell-cell communication is enhanced or not, CellChat compares the the total number of interactions and interaction strength of the inferred cell-cell communication networks from different biological conditions.

##Also generate scatter plots to map senders/receivers for each timepoint
```{r, echo=false}
#analyse immune and stromal separately
immune <- subsetCellChat(cellchat, group.by = "labels", idents.use = c("Neut","Mono/Macs","NK","DC","Tc","Bc"))
stromal <- subsetCellChat(cellchat, group.by = "labels", idents.use = c("Fibroblasts", "MET"))

# Compare interactions in immune cells
gg_immune1 <- compareInteractions(immune, show.legend = FALSE, group = c(1:3), title="Number of interactions (immune cells only)")
gg_immune2 <- compareInteractions(immune, show.legend = FALSE, group = c(1:3), measure = "weight", title="Interaction strength (immune cells only)")

# Compare interactions in all cells
gg1 <- compareInteractions(cellchat, show.legend = FALSE, group = c(1:3), title="Number of interactions")
gg2 <- compareInteractions(cellchat, show.legend = FALSE, group = c(1:3), measure = "weight", title="Interaction strength")
gg1+gg2

# Compare interactions in stromal cells
gg_stromal1 <- compareInteractions(stromal, show.legend = FALSE, group = c(1:3), title="Number of interactions (stromal cells only)")
gg_stromal2 <- compareInteractions(stromal, show.legend = FALSE, group = c(1:3), measure = "weight", , title="Interaction strength (stromal cells only)")

# Plot side by side
gg_immune1+gg_immune2
gg_stromal1+gg_stromal2

#Scatter plots
scatter.control <- netAnalysis_signalingRole_scatter(cellchat.control, title="Signalling Roles by Cell Type - Cycling")
scatter.24 <- netAnalysis_signalingRole_scatter(cellchat.h24, title="Signalling Roles by Cell Type - 24hr")
scatter.48 <- netAnalysis_signalingRole_scatter(cellchat.h48, title="Signalling Roles by Cell Type - 48hr")

get_plot_data <- function(p) ggplot_build(p)$data[[1]]
all_data <- do.call(rbind, lapply(list(scatter.control, scatter.24, scatter.48), get_plot_data))
xr <- range(all_data$x)
yr <- range(all_data$y)

scatter.control + coord_cartesian(xlim=xr, ylim=yr)
scatter.24      + coord_cartesian(xlim=xr, ylim=yr)
scatter.48      + coord_cartesian(xlim=xr, ylim=yr)

```

#Compare interaction strength by cell type
#red = increases over time
#blue = decreases over time
```{r, echo=false}
netVisual_diffInteraction(cellchat, comparison = c(1, 2), weight.scale = T, measure = "weight", title.name = "Communication Changes: Cycling vs 24hr")
title(main = "Communication Changes: Cycling vs 24hr", cex.main = 1.2)
netVisual_diffInteraction(cellchat, comparison = c(1, 3), weight.scale = T, measure = "weight")
netVisual_diffInteraction(cellchat, comparison = c(2, 3), weight.scale = T, measure = "weight")
```

#Circle plots for mapping interactions links
#Heatmaps for analysing interaction strength between cell types at the different timepoints

```{r, echo=false}

# Filter high confidence interactions only (Cycling)
weight_mat <- cellchat.control@net$weight
weight_mat[weight_mat <= 0.5] <- 0  

# Now plot only high-confidence edges
netVisual_circle(
  weight_mat,
  vertex.weight = as.numeric(table(cellchat.control@idents)),
  weight.scale = TRUE,
  label.edge = FALSE
)
title(main = "Cycling (Interaction Strength >0.5)", cex.main = 1.2)


# Filter high confidence interactions only (24h)
weight_mat <- cellchat.h24@net$weight
weight_mat[weight_mat <= 0.5] <- 0

# Now plot only high-confidence edges
netVisual_circle(
  weight_mat,
  vertex.weight = as.numeric(table(cellchat.h24@idents)),
  weight.scale = TRUE,
  label.edge = FALSE
)
title(main = "24hr (Interaction Strength >0.5)", cex.main = 1.2)

# Filter high confidence interactions only (48h)
weight_mat <- cellchat.h48@net$weight
weight_mat[weight_mat <= 0.5] <- 0

# Now plot only high-confidence edges
netVisual_circle(
  weight_mat,
  vertex.weight = as.numeric(table(cellchat.h48@idents)),
  weight.scale = TRUE,
  label.edge = FALSE
)
title(main = "48hr (Interaction Strength >0.5)", cex.main = 1.2)

#Heatmaps
netVisual_heatmap(cellchat.control, title.name = "Number of interactions - Cycling")
netVisual_heatmap(cellchat.h24, title.name = "Number of interactions - 24hr")
netVisual_heatmap(cellchat.h48, title.name = "Number of interactions - 48hr")

```

#What are the top pathways by timepoint?

```{r}
top_cycling <- head(cellchat.control@netP$pathways, 20)
top_24 <- head(cellchat.h24@netP$pathways, 20)
top_48 <- head(cellchat.h48@netP$pathways, 20)

all_pathways <- unique(c(top_cycling, top_24, top_48)) # Merge all top pathways (remove duplicates)
pathway_counts <- table(c(top_cycling, top_24, top_48)) 
top_20_merged <- names(sort(pathway_counts, decreasing = TRUE)[1:20]) # Sort by interaction strength, top 20

# OUTGOING ROLE across all timepoints using same top pathways
print(
  netAnalysis_signalingRole_heatmap(
    cellchat.control,
    pattern = "outgoing",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "Cycling (Top 20 merged pathways)"
  )
)

print(
  netAnalysis_signalingRole_heatmap(
    cellchat.h24,
    pattern = "outgoing",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "24h (Top 20 merged pathways)"
  )
)

print(
  netAnalysis_signalingRole_heatmap(
    cellchat.h48,
    pattern = "outgoing",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "48h (Top 20 merged pathways)"
  )
)

# INCOMING ROLE across all timepoints using same top pathways
print(
  netAnalysis_signalingRole_heatmap(
    cellchat.control,
    pattern = "incoming",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "Cycling (Top 20 merged pathways)"
  )
)

print(
  netAnalysis_signalingRole_heatmap(
    cellchat.h24,
    pattern = "incoming",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "24h (Top 20 merged pathways)"
  )
)

print(
  netAnalysis_signalingRole_heatmap(
    cellchat.h48,
    pattern = "incoming",
    signaling = top_20_merged,
    width = 6, height = 6,
    title = "48h (Top 20 merged pathways)"
  )
)

```

#Identify clusters of pathways based off of functional similarity
#This part of the analysis is built in and easy to run

```{r, echo=false}
#umap-learn is required for this CellChat function to work
library(reticulate)
reticulate::py_install("umap-learn", envname = NULL, pip = TRUE)
py_module_available("umap")
cellchat <- computeNetSimilarityPairwise(cellchat, type = "functional")
cellchat <- netEmbedding(cellchat, type = "functional")
cellchat <- netClustering(cellchat, type = "functional")

# Visualize in 2D embedding
netVisual_embeddingPairwise(cellchat, type = "functional", label.size = 3.5)
netVisual_embeddingPairwiseZoomIn(cellchat, type = "functional", nCol = 2)
rankSimilarity(cellchat, type = "functional")
```

#This part of the analysis is where I had to start playing with dataframes/IDs, so may not error if running all
```{r, echo=false}
## - - - - - Create a dataframe of important information from clustering - - - - -
# Extract cluster assignment
cluster_assignments <- cellchat@netP$similarity$functional$group

# Create dataframe of cluster allocation
cluster_assignments_vec <- unlist(cluster_assignments)
df_clusters <- data.frame(
  pathway_timepoint = names(cluster_assignments_vec),
  cluster = cluster_assignments_vec
)

# Split into timepoint + pathway
df_clusters <- df_clusters %>%
  separate(pathway_timepoint, into = c("pathway","timepoint"), sep = "--", extra = "merge")

# Remove the fixed "1-2-3." prefix from pathway names
df_clusters <- df_clusters %>%
  mutate(pathway = gsub("^1-2-3\\.", "", pathway))

df_clusters <- df_clusters %>%
  mutate(cluster = as.character(cluster)) %>%
  mutate(cluster = recode(cluster,
    "3" = "1",
    "1" = "2",
    "4" = "3",
    "2" = "4"
  ))

# Convert to factor with new levels in desired order
df_clusters$cluster <- factor(df_clusters$cluster, levels = c("1", "2", "3", "4"))

# Cluster <-> color mapping (from scatter plots):
cluster_colors <- c("1" = "#FBB4AE", "2" = "#B3DE69", "3" = "#80B1D3", "4" = "#DDA0DD")

# Count numBER of pathways per cluster per timepoint
counts <- df_clusters %>%
  group_by(cluster, timepoint) %>%
  summarise(num_pathways = n(), .groups = "drop")

# Count number of pathways per cluster
pathways_per_cluster <- df_clusters %>%
  group_by(cluster) %>%
  summarise(n_pathways = n(), .groups = "drop")

# Count number of timepoints per cluster
timepoints_per_cluster <- df_clusters %>%
  group_by(cluster, timepoint) %>%
  summarise(n_timepoints = n_distinct(timepoint), .groups = "drop")

# List of pathways per timepoint per cluster
pathways_per_timepoint_cluster <- df_clusters %>%
  group_by(cluster, timepoint) %>%
  summarise(pathways = paste(pathway, collapse = ", "), .groups = "drop")

# Plot number of pathways per cluster
ggplot(pathways_per_cluster, aes(x = factor(cluster), y = n_pathways, fill = factor(cluster))) +
  geom_bar(stat = "identity") +
  labs(title = "Number of Pathways per Cluster", x = "Cluster", y = "Number of Pathways") +
  theme_minimal() +
  scale_fill_manual(values = cluster_colors) 

# Plot with cluster order/coloUr reflecting CellChat results
ggplot(counts, aes(x = cluster, y = num_pathways, fill = cluster)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~ timepoint) +
  scale_fill_manual(values = cluster_colors) +
  labs(
    x = "Cluster",
    y = "Number of Pathways",
    title = "Number of Pathways per Cluster per Timepoint"
  ) +
  theme_minimal()
```

##Adding communication probability to the dataframe (more additional analysis)
```{r, echo=false}
# Create the full pathway-timepoint name in df_clusters
df_clusters <- df_clusters %>%
  mutate(full_name = paste(pathway, timepoint, sep = "--"))

# Pull communication probabilities from functional matrix
comm_probabilities <- cellchat@netP$similarity$functional$matrix[[1]]

# Calculate the average communication probability for each pathway (mean across the row)
comm_probabilities_avg <- apply(comm_probabilities, 1, mean)

# Create a data frame with the pathway names and corresponding communication probabilities
df_comm_prob <- data.frame(
  pathway = rownames(comm_probabilities),
  comm_probability = comm_probabilities_avg
)

# Split into timepoint + pathway
df_comm_prob <- df_comm_prob %>%
  separate(pathway, into = c("pathway","timepoint"), sep = "--", extra = "merge")

# Remove the fixed "1-2-3." prefix from pathway names
df_clusters <- df_clusters %>%
  mutate(pathway = gsub("^1-2-3\\.", "", pathway))

# Create column from row names
df_comm_prob <- data.frame(
  pathway_timepoint = rownames(df_comm_prob),
  df_comm_prob,  # Add the rest of the columns
  stringsAsFactors = FALSE
)

# Join cluster dataframe and communication probability dataframes by pathway-timepoint ID
df_clusters <- df_clusters %>%
  left_join(df_comm_prob, by = c("full_name" = "pathway_timepoint"))

df_clusters <- df_clusters %>%
  select(-pathway.y, -timepoint.y)

#write.csv(df_clusters, file="df_functional_clusters_26.7.2025.csv")

df_clusters_sorted <- df_clusters %>%
  arrange(cluster, desc(comm_probability))  # Sort pathways by communication probability (descending)

# Select top 3 pathways per cluster to check this has worked
top_3_pathways <- df_clusters_sorted %>%
  group_by(cluster) %>%
  slice_head(n = 3)  # Select top 3 rows per cluster

print(top_3_pathways)

```

#View top 10 pathways by communication probability for each cluster (more dataframe analysis)

```{r}
# Sort and get top 10 pathways by communication probability within each cluster
top_10_cluster_pathways <- df_clusters %>%
  group_by(cluster) %>%
  arrange(cluster, desc(comm_probability)) %>%
  slice_head(n = 10)  # Get the top 10 pathways per cluster

# View the top 10 pathways per cluster
print(top_10_cluster_pathways)
max_comm_prob <- max(top_10_cluster_pathways$comm_probability)

# Sort and get top 10 pathways by communication probability within each timepoint
top_10_timepoint_pathways <- df_clusters %>%
  group_by(timepoint.x) %>%
  arrange(timepoint.x, desc(comm_probability)) %>%
  slice_head(n = 10)  # Get the top 10 pathways per timepoint

# View the top 10 pathways per timepoint
print(top_10_timepoint_pathways)


# Loop through each cluster and plot separately
for(cluster_id in unique(top_10_cluster_pathways$cluster)) {
  
  # Filter data for the current cluster
  cluster_data <- top_10_cluster_pathways %>%
    filter(cluster == cluster_id)
  
  # Create the plot for the current cluster
  p <- ggplot(cluster_data, aes(x = reorder(pathway.x, comm_probability), y = comm_probability, fill = factor(cluster))) +
    geom_bar(stat = "identity") +
    labs(title = paste("Top 10 Pathways - Cluster", cluster_id),
         x = "Pathway", y = "Communication Probability") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("1" = "#66c2a5", "2" = "#fc8d62", "3" = "#8da0cb", "4" = "#e78ac3")) +
    ylim(0, max_comm_prob)  + theme(legend.position="none")
  print(p)
}

# Loop through each cluster and plot separately
for(timepoint_id in unique(top_10_timepoint_pathways$timepoint.x)) {
  
  # Filter data for the current cluster
  timepoint_data <- top_10_timepoint_pathways %>%
    filter(timepoint.x == timepoint_id)
  
  # Create the plot for the current cluster
  # Plot top 10 pathways by communication probability for each timepoint (individual plots)
  p <- ggplot(timepoint_data, aes(x = reorder(pathway.x, comm_probability), y = comm_probability, fill = factor(timepoint.x))) +
    geom_bar(stat = "identity") +
    labs(title = "Top 10 Pathways by Communication Probability per Timepoint", x = "Pathway", y = "Communication Probability") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Cycling" = "#66c2a5", "H24" = "#fc8d62", "H48" = "#8da0cb"))+
    ylim(0, max_comm_prob)
  print(p)
}

# Correlation between communication probability and other factors (e.g., cluster)
cor_analysis <- df_clusters %>%
  group_by(cluster) %>%
  summarise(correlation = cor(comm_probability, as.numeric(factor(cluster))))

print(cor_analysis)

# Boxplot showing distribution of communication probabilities by cluster
ggplot(df_clusters, aes(x = factor(cluster), y = comm_probability, fill = factor(cluster))) +
  geom_boxplot() +
  labs(title = "Distribution of Communication Probabilities by Cluster", x = "Cluster", y = "Communication Probability") +
  theme_minimal() +
  scale_fill_manual(values = c("1" = "#66c2a5", "2" = "#fc8d62", "3" = "#8da0cb", "4" = "#e78ac3"))


```


#Compare the overall information flow of each signaling pathway

```{r, echo=false, fig.width=10, fig.height=10}
gg1 <- rankNet(cellchat, mode = "comparison", stacked = T, do.stat = TRUE)
gg2 <- rankNet(cellchat, mode = "comparison", stacked = F, do.stat = TRUE)
gg1
gg2

netVisual_clustering(cellchat, type = "functional", cluster.id = 1) # for Cluster 1
netVisual_clustering(cellchat, type = "functional", cluster.id = 2) # for Cluster 2
netVisual_clustering(cellchat, type = "functional", cluster.id = 3) # for Cluster 3
netVisual_clustering(cellchat, type = "functional", cluster.id = 4) # for Cluster 4
```


# Visualise top pathways per cluster in a heatmap
```{r, echo=false}
# Store the pathway lists in a named list
pathway_lists <- list(
  Cluster_1 = c("TENASCIN", "GAP", "ADGRA", "MPZ", "PDGF", "RA", "ncWNT", "CDH5"),
  Cluster_2 = c("COLLAGEN", "GALECTIN", "CCL", "FN1", "APP", "THBS", "SPP1", "MIF", "MK"),
  Cluster_3 = c("MHC-I", "CLEC", "CypA", "CD52", "MHC-II", "CXCL", "ANNEXIN", "MMP", "IL1", "OSM", "CD45", "SELL"),
  Cluster_4 = c("RA", "GAP", "GAS", "ncWNT", "Testosterone", "TWEAK", "Cholesterol", "DHT", "EPHB", "IGF", "NEGR")
)



# Loop through each pathway list
for (pathway_name in names(pathway_lists)) {
  
  pathways.show <- pathway_lists[[pathway_name]]
  
  cat("\n\n### Generating heatmaps for", pathway_name, "###\n")
  
  # Heatmap for cellchat.control
  print(
    netAnalysis_signalingRole_heatmap(
      cellchat.control,
      pattern = "all",
      signaling = pathways.show,
      width = 6, height = 6,
      title = paste("Cycling -", pathway_name),
      color.heatmap = "OrRd"
    )
  )
  
  # Heatmap for cellchat.h24
  print(
    netAnalysis_signalingRole_heatmap(
      cellchat.h24,
      pattern = "all",
      signaling = pathways.show,
      width = 6, height = 6,
      title = paste("24hrs -", pathway_name),
      color.heatmap = "OrRd"
    )
  )
  
  # Heatmap for cellchat.h48
  print(
    netAnalysis_signalingRole_heatmap(
      cellchat.h48,
      pattern = "all",
      signaling = pathways.show,
      width = 6, height = 6,
      title = paste("48hrs -", pathway_name),
      color.heatmap = "OrRd"
    )
  )
}

write.csv(top_pathways_per_cluster, "top_pathways_per_cluster.csv")

```


#Create chord plots for a pathway for interest

```{r, fig.width=12,fig.height = 6, fig.wide = TRUE, fig.align = "center"}
# Chord diagram
pathways.show <- c("IL1") 
netVisual_aggregate(cellchat.control, signaling = pathways.show, layout = "chord", signaling.name = paste(pathways.show, "- Cycling"))
netVisual_aggregate(cellchat.h24, signaling = pathways.show, layout = "chord", signaling.name = paste(pathways.show, "- 24hrs"))
netVisual_aggregate(cellchat.h48, signaling = pathways.show, layout = "chord", signaling.name = paste(pathways.show, "- 48hrs"))
```


# Analysis of Ligand-receptor pairs within the IL-1 pathway
```{r, echo=false}
library(tidyverse)

# Convert matrix to data frame
prob_df <- as.data.frame(cellchat@netP$H48$prob)

# Add rownames as 'source'
prob_df$source <- rownames(prob_df)

# Pivot to long format
prob_df_long <- pivot_longer(prob_df, -source, names_to = "target", values_to = "probability")

# View
head(prob_df_long)

met_targets <- prob_df_long %>%
  filter(str_detect(target, "MET"))

# View result
head(met_targets)

object.list <- list(
  H24 = cellchat.h24,
  H48 = cellchat.h48
)

cellchat <- mergeCellChat(object.list, add.names = names(object.list))


test <- netVisual_bubble(cellchat, sources.use = c(2, 5, 6, 7, 8), targets.use = 4,  comparison = c(1,2), max.dataset = 2, title.name = "Increased signaling in LS", angle.x = 45, remove.isolate = F)
test

gg1 <- netVisual_bubble(cellchat, sources.use = c(2, 5, 6, 7, 8), targets.use = 4, comparison = c(1,2), signaling = "IL1", max.dataset = 2, title.name = "Signalling via IL-1", angle.x = 45, remove.isolate = F)
gg1

gg2 <- netVisual_bubble(
  object = cellchat.h24,
  sources.use = c(2, 5:8),
  targets.use = 4,
  signaling = "IL1",
  max.dataset = 2,
  title.name = "Signalling via IL1 at 24hrs",
  angle.x = 45,
  remove.isolate = FALSE,
  thresh = 1000   # <-- disable significance filtering
)
gg2

gg3 <- netVisual_bubble(
  object = cellchat.h48,
  sources.use = c(2, 5:8),
  targets.use = 4,
  signaling = "IL1",
  max.dataset = 2,
  title.name = "Signalling via IL1 at 48hrs",
  angle.x = 45,
  remove.isolate = FALSE,
  thresh = 1000   # <-- disable significance filtering
)
gg3



# show all the significant interactions (L-R pairs) associated with certain signaling pathways
netVisual_chord_gene(cellchat.h24, sources.use = c(2,5:8), targets.use = 4, signaling = c("IL1"))
netVisual_chord_gene(cellchat.h48, sources.use = c(2,5:8), targets.use = 4, signaling = c("IL1"))
```

```{r}
saveRDS(cellchat, file = "cellchat_timepoint_comparison_2025.rds")
```



